/**
 * G-Code Parser
 * Extracts metadata from standard G-code files (OctoPrint, Moonraker, PrusaSlicer format)
 *
 * Metadata is typically stored as comments at the beginning of the file:
 * - PrusaSlicer: "; key = value"
 * - Cura: ";key:value" or "; key = value"
 * - Simplify3D: "; key,value"
 */

import fs from 'fs';
import path from 'path';

export class GCodeParser {
  constructor() {
    this.metadata = {};
    this.thumbnails = [];
  }

  /**
   * Parse a G-code file and extract all metadata
   * @param {string} filePath - Path to the G-code file
   * @returns {Object} Parsed metadata
   */
  parse(filePath) {
    console.log(`\nParsing G-code file: ${ path.basename(filePath) }`);

    this.metadata = {
      _fileName: path.basename(filePath),
      _fileType: 'gcode',
      _parseDate: new Date().toISOString(),
    };
    this.thumbnails = [];


    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');

    let inThumbnail = false;
    let thumbnailData = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Skip empty lines
      if (!line) continue;

      // Thumbnail handling
      if (line.includes('thumbnail') && (line.includes('begin') || line.includes('_QOI begin'))) {
        inThumbnail = true;
        const match = line.match(/(\d+)x(\d+)\s+(\d+)/);
        if (match) {
          thumbnailData = {
            width: parseInt(match[1]),
            height: parseInt(match[2]),
            size: parseInt(match[3]),
            format: line.includes('_QOI') ? 'QOI' : (line.includes('_PNG') ? 'PNG' : 'unknown'),
            data: ''
          };
        }
        continue;
      }

      if (inThumbnail && (line.includes('thumbnail end') || line.includes('_QOI end'))) {
        if (thumbnailData) {
          this.thumbnails.push(thumbnailData);
        }
        inThumbnail = false;
        thumbnailData = null;
        continue;
      }

      if (inThumbnail && thumbnailData) {
        // Check if this looks like thumbnail data (base64-ish) or actual content
        const cleanLine = line.replace(/^;\s*/, '');
        const isBase64Like = /^[A-Za-z0-9+/=]+$/.test(cleanLine);

        if (isBase64Like && cleanLine.length > 10) {
          // Still in thumbnail data
          thumbnailData.data += cleanLine;
          continue;
        } else {
          // This line doesn't look like thumbnail data - thumbnail must have ended
          if (thumbnailData) {
            this.thumbnails.push(thumbnailData);
          }
          inThumbnail = false;
          thumbnailData = null;
          // Don't continue - process this line normally below
        }
      }

      // Parse all metadata comment lines
      if (line.startsWith(';')) {
        this.parseMetadataLine(line);
      }
    }

    // Add thumbnail info to metadata
    if (this.thumbnails.length > 0) {
      this.metadata._thumbnails = this.thumbnails.map(t => ({
        width: t.width,
        height: t.height,
        size: t.size,
        format: t.format,
        dataLength: t.data.length
      }));
    }

    return this.getNormalizedMetadata();
  }

  /**
   * Parse a single metadata line
   * @param {string} line - Comment line to parse
   */
  parseMetadataLine(line) {
    // Remove leading semicolon and whitespace
    line = line.substring(1).trim();

    // Skip empty lines and special markers
    if (!line || line.startsWith('thumbnail') || line.startsWith('TYPE:')) {
      return;
    }

    // Try different metadata formats

    // Format 1: "key = value" (PrusaSlicer, most common) - check this FIRST
    let match = line.match(/^([^=]+?)\s*=\s*(.+)$/);
    if (match) {
      const key = match[1].trim();
      const value = match[2].trim();
      this.metadata[key] = this.parseValue(value);
      return;
    }

    // Format 2: "key:value" (Cura) - but avoid matching "generated by" or other descriptive text
    // Only match if the key looks like a valid identifier (no spaces before colon)
    match = line.match(/^([a-zA-Z_][a-zA-Z0-9_\s]*?)\s*:\s*(.+)$/);
    if (match && !match[1].includes(' ')) {
      const key = match[1].trim();
      const value = match[2].trim();
      this.metadata[key] = this.parseValue(value);
      return;
    }

    // Format 3: "key,value" (Simplify3D)
    match = line.match(/^([^,]+?),(.+)$/);
    if (match) {
      const key = match[1].trim();
      const value = match[2].trim();
      this.metadata[key] = this.parseValue(value);
      return;
    }

    // Store descriptive comments separately
    if (line.startsWith('generated by') || line.startsWith('produced by')) {
      this.metadata._generatedBy = line;
      return;
    }

    // Store as-is if no pattern matches (might be a description or note)
    if (line.length < 100) { // Avoid storing long descriptions
      if (!this.metadata._comments) {
        this.metadata._comments = [];
      }
      this.metadata._comments.push(line);
    }
  }

  /**
   * Parse a value string into appropriate type
   * @param {string} value - Value string to parse
   * @returns {any} Parsed value
   */
  parseValue(value) {
    // Try to parse as number
    if (/^-?\d+\.?\d*$/.test(value)) {
      return parseFloat(value);
    }

    // Try to parse as boolean
    if (value.toLowerCase() === 'true') return true;
    if (value.toLowerCase() === 'false') return false;

    // Try to parse as JSON (for arrays/objects)
    if (value.startsWith('{') || value.startsWith('[')) {
      try {
        return JSON.parse(value);
      } catch (e) {
        // Not valid JSON, return as string
      }
    }

    // Return as string
    return value;
  }

  /**
   * Get metadata normalized to PrintJob entity fields
   * @returns {Object} Normalized metadata
   */
  getNormalizedMetadata() {
    const raw = this.metadata;

    return {
      raw: raw,
      normalized: {
        // Print time fields
        gcodePrintTimeSeconds: this.extractPrintTime(raw),

        // Filament specification
        nozzleDiameterMm: this.extractNumber(raw, [
          'nozzle_diameter',
          'machine_nozzle_size',
          'extruderSize'
        ]),

        filamentDiameterMm: this.extractNumber(raw, [
          'filament_diameter',
          'material_diameter',
          'filament_diameter_mm'
        ]),

        filamentDensityGramsCm3: this.extractNumber(raw, [
          'filament_density',
          'material_density'
        ]),

        // Filament usage
        filamentUsedMm: this.extractFilamentLength(raw),
        filamentUsedCm3: this.extractFilamentVolume(raw),
        filamentUsedGrams: this.extractFilamentWeight(raw),
        totalFilamentUsedGrams: this.extractTotalFilamentWeight(raw),

        // Additional useful fields
        fileName: raw._fileName,
        layerHeight: this.extractNumber(raw, ['layer_height', 'layerHeight']),
        firstLayerHeight: this.extractNumber(raw, ['first_layer_height', 'firstLayerHeight']),
        bedTemperature: this.extractNumber(raw, ['bed_temperature', 'material_bed_temperature', 'bedTemp']),
        nozzleTemperature: this.extractNumber(raw, ['temperature', 'material_print_temperature', 'extruderTemp']),
        fillDensity: this.extractString(raw, ['fill_density', 'infill_sparse_density', 'infillPercent']),
        filamentType: this.extractString(raw, ['filament_type', 'material_type', 'filamentType']),
        printerModel: this.extractString(raw, ['printer_model', 'machine_name', 'printerName']),
        slicerVersion: this.extractString(raw, ['generated by PrusaSlicer', 'generated by Slic3r']),
        maxLayerZ: this.extractNumber(raw, ['max_layer_z', 'maxZ']),
      }
    };
  }

  extractPrintTime(raw) {
    // Look for estimated printing time in various formats
    const keys = [
      'estimated printing time (normal mode)',
      'estimated printing time',
      'estimatedPrintTime',
      'print_time'
    ];

    for (const key of keys) {
      if (raw[key]) {
        return this.parseTimeToSeconds(raw[key]);
      }
    }

    return null;
  }

  parseTimeToSeconds(timeStr) {
    if (typeof timeStr === 'number') return timeStr;
    if (typeof timeStr !== 'string') return null;

    // Parse formats like "1h 31m 17s" or "3m 41s"
    let totalSeconds = 0;

    const hoursMatch = timeStr.match(/(\d+)h/);
    if (hoursMatch) totalSeconds += parseInt(hoursMatch[1]) * 3600;

    const minutesMatch = timeStr.match(/(\d+)m/);
    if (minutesMatch) totalSeconds += parseInt(minutesMatch[1]) * 60;

    const secondsMatch = timeStr.match(/(\d+)s/);
    if (secondsMatch) totalSeconds += parseInt(secondsMatch[1]);

    return totalSeconds > 0 ? totalSeconds : null;
  }

  extractFilamentLength(raw) {
    const value = this.extractNumber(raw, [
      'filament used [mm]',
      'filament_used_mm',
      'filament used [m]'
    ]);

    // Convert from meters to mm if needed
    if (raw['filament used [m]'] && value) {
      return value * 1000;
    }

    return value;
  }

  extractFilamentVolume(raw) {
    return this.extractNumber(raw, [
      'filament used [cm3]',
      'filament_used_cm3',
      'filamentVolume'
    ]);
  }

  extractFilamentWeight(raw) {
    return this.extractNumber(raw, [
      'filament used [g]',
      'filament_used_g',
      'filamentWeight'
    ]);
  }

  extractTotalFilamentWeight(raw) {
    return this.extractNumber(raw, [
      'total filament used [g]',
      'total_filament_used_g',
      'totalFilamentWeight'
    ]);
  }

  extractNumber(raw, keys) {
    for (const key of keys) {
      if (raw[key] !== undefined && raw[key] !== null) {
        const value = raw[key];
        if (typeof value === 'number') return value;
        if (typeof value === 'string') {
          // Remove units and parse
          const cleaned = value.replace(/[^\d.-]/g, '');
          const parsed = parseFloat(cleaned);
          if (!isNaN(parsed)) return parsed;
        }
      }
    }
    return null;
  }

  extractString(raw, keys) {
    for (const key of keys) {
      if (raw[key] !== undefined && raw[key] !== null) {
        return String(raw[key]);
      }
    }
    return null;
  }
}

// If run directly, parse a file
if (process.argv[1] === new URL(import.meta.url).pathname.replace(/^\/([A-Z]:)/, '$1')) {
  const filePath = process.argv[2] || path.join(path.dirname(new URL(import.meta.url).pathname.replace(/^\/([A-Z]:)/, '$1')), '..', '..', 'sample.gcode');
  const parser = new GCodeParser();
  const result = parser.parse(filePath);
  console.log('\n=== G-Code Metadata ===');
  console.log(JSON.stringify(result, null, 2));
}

export default GCodeParser;

